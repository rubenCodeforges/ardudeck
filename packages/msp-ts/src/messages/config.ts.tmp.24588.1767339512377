/**
 * MSP Configuration Messages
 *
 * PID, RC_TUNING, MODE_RANGES, FEATURE_CONFIG
 */

import { MSP } from '../core/constants.js';
import { PayloadReader, PayloadBuilder } from '../core/msp-serializer.js';

// =============================================================================
// Types
// =============================================================================

export interface MSPPidCoefficients {
  p: number;
  i: number;
  d: number;
}

export interface MSPPid {
  roll: MSPPidCoefficients;
  pitch: MSPPidCoefficients;
  yaw: MSPPidCoefficients;
  // Additional PID controllers (if present)
  altHold?: MSPPidCoefficients;
  posHold?: MSPPidCoefficients;
  posR?: MSPPidCoefficients;
  navR?: MSPPidCoefficients;
  level?: MSPPidCoefficients;
  mag?: MSPPidCoefficients;
  vel?: MSPPidCoefficients;
}

export interface MSPRcTuning {
  rcRate: number;           // RC rate (0-255, represents 0.01-2.55)
  rcExpo: number;           // RC expo (0-100)
  rollPitchRate: number;    // Legacy: combined roll/pitch rate
  yawRate: number;          // Yaw rate
  dynThrPID: number;        // Dynamic throttle PID
  throttleMid: number;      // Throttle mid position
  throttleExpo: number;     // Throttle expo
  tpaBreakpoint: number;    // TPA breakpoint
  rcYawExpo: number;        // RC yaw expo
  rcYawRate: number;        // RC yaw rate
  rcPitchRate: number;      // RC pitch rate
  rcPitchExpo: number;      // RC pitch expo
  rollRate: number;         // Roll super rate
  pitchRate: number;        // Pitch super rate
  yawRateLimit: number;     // Yaw rate limit (Betaflight 4.x)
  ratesType: number;        // Rates type (0=Betaflight, 1=Raceflight, 2=Kiss, 3=Actual, 4=Quick)
}

export interface MSPModeRange {
  boxId: number;        // Mode ID (see MSP_FLIGHT_MODE in constants)
  auxChannel: number;   // AUX channel (0=AUX1, 1=AUX2, etc.)
  rangeStart: number;   // Start of range (900-2100, in steps of 25)
  rangeEnd: number;     // End of range (900-2100, in steps of 25)
}

export interface MSPFeatureConfig {
  features: number;     // Bitmask of enabled features
}

// =============================================================================
// Deserializers
// =============================================================================

/**
 * Deserialize MSP_PID response
 *
 * Returns PID coefficients for roll, pitch, yaw (and optionally more)
 * Each value is 0-255
 */
export function deserializePid(payload: Uint8Array): MSPPid {
  const reader = new PayloadReader(payload);

  // Read PID triplets (P, I, D for each controller)
  const readPid = (): MSPPidCoefficients => ({
    p: reader.readU8(),
    i: reader.readU8(),
    d: reader.readU8(),
  });

  const pid: MSPPid = {
    roll: readPid(),
    pitch: readPid(),
    yaw: readPid(),
  };

  // Optional additional PIDs
  if (reader.remaining() >= 3) pid.altHold = readPid();
  if (reader.remaining() >= 3) pid.posHold = readPid();
  if (reader.remaining() >= 3) pid.posR = readPid();
  if (reader.remaining() >= 3) pid.navR = readPid();
  if (reader.remaining() >= 3) pid.level = readPid();
  if (reader.remaining() >= 3) pid.mag = readPid();
  if (reader.remaining() >= 3) pid.vel = readPid();

  return pid;
}

/**
 * Serialize MSP_SET_PID payload
 */
export function serializePid(pid: MSPPid): Uint8Array {
  const builder = new PayloadBuilder();

  const writePid = (p: MSPPidCoefficients) => {
    builder.writeU8(p.p);
    builder.writeU8(p.i);
    builder.writeU8(p.d);
  };

  writePid(pid.roll);
  writePid(pid.pitch);
  writePid(pid.yaw);

  // Write optional PIDs if present
  if (pid.altHold) writePid(pid.altHold);
  if (pid.posHold) writePid(pid.posHold);
  if (pid.posR) writePid(pid.posR);
  if (pid.navR) writePid(pid.navR);
  if (pid.level) writePid(pid.level);
  if (pid.mag) writePid(pid.mag);
  if (pid.vel) writePid(pid.vel);

  return builder.build();
}

/**
 * Deserialize MSP_RC_TUNING response
 *
 * Returns rate/expo settings
 */
export function deserializeRcTuning(payload: Uint8Array): MSPRcTuning {
  const reader = new PayloadReader(payload);

  const rcTuning: MSPRcTuning = {
    rcRate: reader.readU8(),
    rcExpo: reader.readU8(),
    rollPitchRate: reader.readU8(),
    yawRate: reader.readU8(),
    dynThrPID: reader.readU8(),
    throttleMid: reader.readU8(),
    throttleExpo: reader.readU8(),
    tpaBreakpoint: reader.remaining() >= 2 ? reader.readU16() : 1500,
    rcYawExpo: reader.remaining() >= 1 ? reader.readU8() : 0,
    rcYawRate: reader.remaining() >= 1 ? reader.readU8() : 0,
    rcPitchRate: reader.remaining() >= 1 ? reader.readU8() : 0,
    rcPitchExpo: reader.remaining() >= 1 ? reader.readU8() : 0,
    rollRate: reader.remaining() >= 1 ? reader.readU8() : 0,
    pitchRate: reader.remaining() >= 1 ? reader.readU8() : 0,
    yawRateLimit: reader.remaining() >= 2 ? reader.readU16() : 0,
    ratesType: reader.remaining() >= 1 ? reader.readU8() : 0,
  };

  return rcTuning;
}

/**
 * Serialize MSP_SET_RC_TUNING payload
 */
export function serializeRcTuning(rcTuning: MSPRcTuning): Uint8Array {
  const builder = new PayloadBuilder();

  builder.writeU8(rcTuning.rcRate);
  builder.writeU8(rcTuning.rcExpo);
  builder.writeU8(rcTuning.rollPitchRate);
  builder.writeU8(rcTuning.yawRate);
  builder.writeU8(rcTuning.dynThrPID);
  builder.writeU8(rcTuning.throttleMid);
  builder.writeU8(rcTuning.throttleExpo);
  builder.writeU16(rcTuning.tpaBreakpoint);
  builder.writeU8(rcTuning.rcYawExpo);
  builder.writeU8(rcTuning.rcYawRate);
  builder.writeU8(rcTuning.rcPitchRate);
  builder.writeU8(rcTuning.rcPitchExpo);
  builder.writeU8(rcTuning.rollRate);
  builder.writeU8(rcTuning.pitchRate);
  builder.writeU16(rcTuning.yawRateLimit);
  builder.writeU8(rcTuning.ratesType);

  return builder.build();
}

/**
 * Deserialize MSP_MODE_RANGES response
 *
 * Returns array of mode range configurations
 */
export function deserializeModeRanges(payload: Uint8Array): MSPModeRange[] {
  const reader = new PayloadReader(payload);
  const modes: MSPModeRange[] = [];

  // Each mode range is 4 bytes
  while (reader.remaining() >= 4) {
    const boxId = reader.readU8();
    const auxChannel = reader.readU8();
    const rangeStartStep = reader.readU8();
    const rangeEndStep = reader.readU8();

    // Convert step values to PWM (step 0 = 900, step 48 = 2100)
    modes.push({
      boxId,
      auxChannel,
      rangeStart: 900 + rangeStartStep * 25,
      rangeEnd: 900 + rangeEndStep * 25,
    });
  }

  return modes;
}

/**
 * Serialize a single MSP_SET_MODE_RANGE payload
 *
 * Note: SET_MODE_RANGE sets one range at a time, index is prepended
 */
export function serializeModeRange(index: number, mode: MSPModeRange): Uint8Array {
  const builder = new PayloadBuilder();

  builder.writeU8(index);
  builder.writeU8(mode.boxId);
  builder.writeU8(mode.auxChannel);
  builder.writeU8(Math.round((mode.rangeStart - 900) / 25));
  builder.writeU8(Math.round((mode.rangeEnd - 900) / 25));

  return builder.build();
}

/**
 * Deserialize MSP_FEATURE_CONFIG response
 */
export function deserializeFeatureConfig(payload: Uint8Array): MSPFeatureConfig {
  const reader = new PayloadReader(payload);

  return {
    features: reader.readU32(),
  };
}

/**
 * Serialize MSP_SET_FEATURE_CONFIG payload
 */
export function serializeFeatureConfig(config: MSPFeatureConfig): Uint8Array {
  const builder = new PayloadBuilder();
  builder.writeU32(config.features);
  return builder.build();
}

// =============================================================================
// Feature Flags
// =============================================================================

export const FEATURE_FLAGS: Record<number, string> = {
  0: 'RX_PPM',
  2: 'INFLIGHT_ACC_CAL',
  3: 'RX_SERIAL',
  4: 'MOTOR_STOP',
  5: 'SERVO_TILT',
  6: 'SOFTSERIAL',
  7: 'GPS',
  9: 'SONAR',
  10: 'TELEMETRY',
  12: '3D',
  13: 'RX_PARALLEL_PWM',
  14: 'RX_MSP',
  15: 'RSSI_ADC',
  16: 'LED_STRIP',
  17: 'DISPLAY',
  18: 'OSD',
  20: 'CHANNEL_FORWARDING',
  21: 'TRANSPONDER',
  22: 'AIRMODE',
  25: 'RX_SPI',
  27: 'ESC_SENSOR',
  28: 'ANTI_GRAVITY',
  29: 'DYNAMIC_FILTER',
};

/**
 * Get list of enabled feature names from bitmask
 */
export function getEnabledFeatures(featureMask: number): string[] {
  const enabled: string[] = [];
  for (const [bit, name] of Object.entries(FEATURE_FLAGS)) {
    if ((featureMask & (1 << parseInt(bit))) !== 0) {
      enabled.push(name);
    }
  }
  return enabled;
}

// =============================================================================
// Mode Names
// =============================================================================

export const MODE_NAMES: Record<number, string> = {
  0: 'ARM',
  1: 'ANGLE',
  2: 'HORIZON',
  3: 'MAG',
  4: 'HEADFREE',
  5: 'PASSTHRU',
  6: 'FAILSAFE',
  7: 'GPS RESCUE',
  8: 'ANTI GRAVITY',
  13: 'BEEPER',
  15: 'LED LOW',
  19: 'OSD DISABLE',
  26: 'BLACKBOX',
  28: 'AIRMODE',
  35: 'PID AUDIO',
  36: 'PARALYZE',
  39: 'BEEPER GPS',
  40: 'VTX CONTROL',
  41: 'LAUNCH CONTROL',
};

/**
 * Get mode name from box ID
 */
export function getModeName(boxId: number): string {
  return MODE_NAMES[boxId] ?? `MODE ${boxId}`;
}

// =============================================================================
// Rate Type Names
// =============================================================================

export const RATES_TYPE_NAMES: Record<number, string> = {
  0: 'Betaflight',
  1: 'Raceflight',
  2: 'KISS',
  3: 'Actual',
  4: 'Quick',
};
